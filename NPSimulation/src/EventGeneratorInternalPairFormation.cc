/*****************************************************************************
 * Copyright (C) 2009-2013   this file is part of the NPTool Project         *
 *                                                                           *
 * For the licensing terms see $NPTOOL/Licence/NPTool_Licence                *
 * For the list of contributors see $NPTOOL/Licence/Contributors             *
 *****************************************************************************/

/*****************************************************************************
 *          Author: Mohamad Moukaddam  contact address: moukaddam@triumf.ca  *
 * class structure based on other generators from                            *
 * Original Author: Adrien MATTA  contact address: matta@ipno.in2p3.fr       *                                                                         *
 * Creation Date  : Apr 2014                                                 *
 * Last update    :                                                          *
 *---------------------------------------------------------------------------*
 * Decription:                                                               *
 *  This event Generator is used to simulated an internal pair formation of  *
 *  nuclei generated by previous event generator. Multiple cases are 		 *
 *  supported:            													 *
 *  - E0, a Cross section can be given   						             *
 *  - E0, a Cross section calculated   						                 *
 *  - E{1,..,5} or M{1,..,5}  a Cross section calculated                     *
 *  - If more than one cascade are given, Branching Ratio could be given     *
 *                                                                           *
 *---------------------------------------------------------------------------*
 * Comment:                                                                  *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *****************************************************************************/

#include "EventGeneratorInternalPairFormation.hh"

// NPS
#include "Particle.hh"

// NPL
#include "NPOptionManager.h"
#include "NPFunction.h"
using namespace NPL;

// G4 headers including CLHEP headers
// for generating random numbers
#include "Randomize.hh"

// G4
#include "G4ParticleTable.hh"

// ROOT
#include "TLorentzVector.h"
#include "TVector3.h"

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
EventGeneratorInternalPairFormation::EventGeneratorInternalPairFormation(){
  m_ParticleStack = ParticleStack::getInstance();
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
EventGeneratorInternalPairFormation::~EventGeneratorInternalPairFormation(){
  m_CrossSectionLeptonHist2D.clear();
  
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
void EventGeneratorInternalPairFormation::ReadConfiguration(string Path, int Occurence){
  ////////General Reading needs////////
  string LineBuffer;
  string DataBuffer;
  istringstream LineStream;
  int TokenOccurence = 0 ;
  //////// Setting needs///////
  unsigned int NumberOfCascade = 0;
  bool ReadingStatusInternalPairFormation  = false ;
  bool CascadeStatus = false ;
  
//Lepton conversion specefic 
  bool check_created = false;
  bool check_E = false;
  bool check_BranchingRatio = false;
  bool check_Field = false;
  bool check_Polarity = false ;
  bool check_Ipf = false ;
  bool check_Ice = false;
  bool check_CSLeptonPath = false ;
    
  int VerboseLevel = NPOptionManager::getInstance()->GetVerboseLevel();
  
  //////////////////////////////////////////////////////////////////////////////////////////
  ifstream InputFile;
  InputFile.open(Path.c_str());
  
  if (InputFile.is_open()) {} else {
    return;
  }
  
  while (!InputFile.eof() && !check_created) {
    //Pick-up next line
    getline(InputFile, LineBuffer);
    
    if (LineBuffer.compare(0, 9, "PairDecay") == 0) {
      TokenOccurence++;
      if (TokenOccurence == Occurence) {
        ReadingStatusInternalPairFormation = true ;
        if(VerboseLevel==1) G4cout << "///////////////////////////////////////// " << G4endl;
        // Get the nuclei name
        LineStream.clear();
        LineStream.str(LineBuffer);
        LineStream >> DataBuffer;
        DataBuffer.erase();
        LineStream >> DataBuffer;
        m_NucleiName = DataBuffer ;
        if(VerboseLevel==1) G4cout << "Pair Decay for " << m_NucleiName << G4endl;
      }
    }
    
    ///////////////////////////////
    /// Pair Decay case
    while(ReadingStatusInternalPairFormation){
      InputFile >> DataBuffer;
      //Search for comment Symbol %
      if (DataBuffer.compare(0, 1, "%") == 0) {   InputFile.ignore ( std::numeric_limits<std::streamsize>::max(), '\n' );}
      
      else if (DataBuffer == "Cascade") {
        CascadeStatus = true ;
        NumberOfCascade++;
        if(VerboseLevel==1)         G4cout << "  Cascade " << NumberOfCascade << G4endl;
        
        LineStream.clear();
        LineStream.str(LineBuffer);
        
        // Instantiate new variable for the up coming cascade
        check_E = false;
        check_Field = false;
        check_Polarity = false;
        check_Ipf = false;
        check_Ice = false;
        check_BranchingRatio = false;
        check_CSLeptonPath = false ; 
               
        double BranchingRatio = -1;
        vector<double> E ;
        vector<string> Field ;
        vector<double> Polarity ;
        vector<double> InternalPairCoeff ; // InternalPairCoeff
        vector<double> InternalElectronCoeff ; // InternalElectronCoeff
        vector<string> CSpairPath ;
        vector<string> CSpairName ;
                
        while (CascadeStatus) {
          getline(InputFile, LineBuffer);
          LineStream.clear();
          LineStream.str(LineBuffer);
          LineStream >> DataBuffer ;
          
           G4cout << DataBuffer << G4endl;
          
          //Search for comment Symbol %
          if (DataBuffer.compare(0, 1, "%") == 0) {   InputFile.ignore ( std::numeric_limits<std::streamsize>::max(), '\n' );}
          
          else if(DataBuffer == "BranchingRatio=") {
            check_BranchingRatio = true;
            LineStream.clear();
            LineStream.str(LineBuffer);
            LineStream >> DataBuffer ;
            LineStream >> DataBuffer ;
            BranchingRatio = atof(DataBuffer.c_str());
            if(VerboseLevel==1)             G4cout << "    Branching Ratio: " << atof(DataBuffer.c_str()) << G4endl;
            
          }
         
          else if(DataBuffer == "Energies=") {
            check_E = true;
            if(VerboseLevel==1)             G4cout << "    Energies: " ;
            LineStream.clear();
            LineStream.str(LineBuffer);
            LineStream >> DataBuffer;
            while(LineStream >> DataBuffer){
              E.push_back(atof(DataBuffer.c_str()));
              if(VerboseLevel==1)G4cout << atof(DataBuffer.c_str()) << " ";
              
            }
            if(VerboseLevel==1)G4cout << G4endl;
          }
          
          else if(DataBuffer == "FieldTypes=") {
            check_Field = true;
            if(VerboseLevel==1)             G4cout << "    Field types: " ;
            LineStream.clear();
            LineStream.str(LineBuffer);
            LineStream >> DataBuffer;
            while(LineStream >> DataBuffer){
              Field.push_back(DataBuffer);
              if(VerboseLevel==1)G4cout << DataBuffer << " ";
              
            }
            if(VerboseLevel==1)G4cout << G4endl;
          }
          
          
          else if(DataBuffer == "PolarityOrders=") {
            check_Polarity = true;
            if(VerboseLevel==1)             G4cout << "    Polarity Orders: " ;
            LineStream.clear();
            LineStream.str(LineBuffer);
            LineStream >> DataBuffer;
            while(LineStream >> DataBuffer){
              Polarity.push_back(atof(DataBuffer.c_str()));
              if(VerboseLevel==1)G4cout << atof(DataBuffer.c_str()) << " ";
              
            }
            if(VerboseLevel==1)G4cout << G4endl;
          }

          else if(DataBuffer == "InternalPairCoeff=") {
            check_Ipf = true;
            if(VerboseLevel==1)             G4cout << "    Total Internal Pair Coeffecients: " ;
            LineStream.clear();
            LineStream.str(LineBuffer);
            LineStream >> DataBuffer;
            while(LineStream >> DataBuffer){
              InternalElectronCoeff.push_back(atof(DataBuffer.c_str()));
              if(VerboseLevel==1)G4cout << atof(DataBuffer.c_str()) << " ";
              
            }
            if(VerboseLevel==1)G4cout << G4endl;
          }    
                       
          else if(DataBuffer == "InternalElectronCoeff=") {
            check_Ice = true;
            if(VerboseLevel==1)             G4cout << "    Total Internal Conversion Coeffecients: " ;
            LineStream.clear();
            LineStream.str(LineBuffer);
            LineStream >> DataBuffer;
            while(LineStream >> DataBuffer){
              InternalElectronCoeff.push_back(atof(DataBuffer.c_str()));
              if(VerboseLevel==1)G4cout << atof(DataBuffer.c_str()) << " ";
              
            }
            if(VerboseLevel==1)G4cout << G4endl;
          }    
                      
          else if(DataBuffer == "DifferentialCrossSectionLepton=") {
            if(VerboseLevel==1)             G4cout << "    Pair Cross Section : " ; 
            LineStream.clear();
            LineStream.str(LineBuffer);
            LineStream >> DataBuffer;
            while(LineStream >> DataBuffer){ // path       
              CSpairPath.push_back(DataBuffer);
              if(VerboseLevel==1) 				G4cout << "        Path:" << DataBuffer << "\t";
              LineStream >> DataBuffer ; // name 
              CSpairName.push_back(DataBuffer);
              if(VerboseLevel==1)               G4cout << "        Name:" << DataBuffer << G4endl;              
            }
            if(VerboseLevel==1)            G4cout << G4endl;
            check_CSLeptonPath = true;
          }                   
          
          // Cascade ended
          if(check_E && check_BranchingRatio && check_Field && check_Polarity && check_Ice && check_Ipf && check_CSLeptonPath){ 
		// add the lepton cascade
		AddLeptonCascade(E, BranchingRatio, Field, Polarity, InternalPairCoeff, InternalElectronCoeff, CSpairPath, CSpairName);
            CascadeStatus = false;
          }
         
          
        }
        
      }
      
      //////////////////////////////////////////////////////
      // If no Token and no comment, toggle out //
      //  else
      //   {ReadingStatusInternalPairFormation = false; G4cout << "WARNING : Wrong Token Sequence: Getting out " << G4endl ;}
      
      if(InputFile.eof()) {ReadingStatusInternalPairFormation=false;check_created=true;}
    }
  }
  if(VerboseLevel==1) G4cout << "///////////////////////////////////////// " << G4endl;
  InputFile.close();
  PrepareCascade();
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
void EventGeneratorInternalPairFormation::GenerateEvent(G4Event*){
  
  // Choose a Cascade to follow
  int ChoosenCascade = -1;
  double RandomNumber = RandFlat::shoot();
  
  for (unsigned int i = 1; i<m_BranchingRatio.size(); i++) {
    if(RandomNumber > m_BranchingRatio[i-1] && RandomNumber< m_BranchingRatio[i])
      ChoosenCascade=i;
  }
  
  if (ChoosenCascade==-1) ChoosenCascade=0;
  
  // Look for the decaying nucleus
  Particle decayingParticle = m_ParticleStack->SearchAndRemoveParticle(m_NucleiName);
  
  if(decayingParticle.GetParticleDefinition()==NULL){
    G4cout << "Pair Decay Warning: The decaying particle " << m_NucleiName
    << " was not found in the particle stack " << G4endl;
    return ;
  }
  // Check for energies conservation (i.e: Cascade Energies lower than Excitation energie)
  string ExcitationString = decayingParticle.GetParticleDefinition()->GetParticleName();
  ExcitationString.erase(0,m_NucleiName.length()+1);
  ExcitationString.erase(ExcitationString.length()-1,ExcitationString.length());
  double ExcitationEnergy = atof(ExcitationString.c_str())*keV;
  
  // Compute the final excitation energy of the decaying nuclei
  double FinalExcitationEnergy = ExcitationEnergy-m_CascadeTotalEnergy[ChoosenCascade];
  if(FinalExcitationEnergy<0){
    G4cout << "Pair Decay Warning: The cascade energy exceed the excitation energy of the decaying nuclei: "
    << G4endl << " Excitation Energy : " << ExcitationEnergy
    << G4endl << " Cascade Energy : "    <<    m_CascadeTotalEnergy[ChoosenCascade] << G4endl;
    FinalExcitationEnergy=0;
  }
  
  // Put back the decaying nucleus with its new excitation energy
  G4ParticleDefinition* FinalParticleDefition
  = G4ParticleTable::GetParticleTable()->GetIon(decayingParticle.GetParticleDefinition()->GetAtomicNumber(), decayingParticle.GetParticleDefinition()->GetAtomicMass(), FinalExcitationEnergy*MeV);
  
  Particle FinalParticle = Particle(  FinalParticleDefition,
                                    decayingParticle.GetParticleThetaCM(),
                                    decayingParticle.GetParticleKineticEnergy(),
                                    decayingParticle.GetParticleMomentumDirection(),
                                    decayingParticle.GetParticlePosition(),
                                    decayingParticle.GetShootStatus());
  
  m_ParticleStack->AddParticleToStack(FinalParticle);
  
  // Instantiate and add the pair e+e- to the particle stack
  for (unsigned int i = 0; i < m_Energies[ChoosenCascade].size(); i++) {
    
	// positron parameters and definition
	G4ParticleDefinition* positronDefinition = G4ParticleTable::GetParticleTable()->FindParticle("positron");
	G4ThreeVector positronDirection;
	double theta_positron=0;
	double phi_positron=0;
	double energy_positron=0;

	
	//electron parameters and definition     
	G4ParticleDefinition* electronDefinition = G4ParticleTable::GetParticleTable()->FindParticle("electron");
	G4ThreeVector electronDirection;
	double theta_electron=0;
	double phi_electron=0;
	double energy_electron=0;
	
	//pair parameteres
	double theta_separation=0;
	double phi_separation=0;
	
	 // Get the separation angle and the positron energy from the given cross section (theta_separation vs Energy_positron)   
      m_CrossSectionHist2D[ChoosenCascade]->GetRandom2(&energy_positron, &theta_separation);
      cout << energy_positron << "  " << theta_separation << endl ; cin.get() ;
      

	  // Build electron direction with respect to the z-axis direction 
      phi_separation   = RandFlat::shoot() * 2. *pi; 
      theta_separation = theta_separation*deg ;
      
	  cout << energy_positron << "  " << theta_separation << endl ; cin.get() ;        
      
      //create the positron direction according to isotropic distribution
      double cos_theta = RandFlat::shoot();   
      theta_positron = acos(cos_theta); 
      phi_positron   = RandFlat::shoot() * 2. *pi;
      positronDirection= G4ThreeVector(cos(phi_positron)*sin(theta_positron),
                                    sin(phi_positron)*sin(theta_positron),
                                    cos(theta_positron));
  
     //create the electron direction as a copy of the positron distribution where the polar angle is incremented by theta_separation
     double phi_electron = phi_positron ; // for now  
     electronDirection= G4ThreeVector(cos(phi_positron)*sin(theta_positron+theta_separation),
                                    sin(phi_positron)*sin(theta_positron+theta_separation),
                                    cos(theta_positron+theta_separation));
                                    
     //rotate the electron direction around the positron vector, this will conserve theta separation.
     phi_separation   = RandFlat::shoot() * 2. *pi;
     electronDirection.rotate(phi_separation,positronDirection);         
   
                                        
   // build energies for pair
    double TransitionEnergy = m_Energies[ChoosenCascade][i];
    double total_energy_positron = energy_positron + electron_mass_c2 ;
    double total_energy_electron = TransitionEnergy - total_energy_positron ;

    // Build Lorentz Vector for pair and decaying particle
    decayingParticle.GetParticleMomentumDirection();
    double NucleiEnergy= decayingParticle.GetParticleKineticEnergy()+FinalParticleDefition->GetPDGMass();
    double NucleiMomentum= sqrt(NucleiEnergy*NucleiEnergy-FinalParticleDefition->GetPDGMass()*FinalParticleDefition->GetPDGMass());
    TLorentzVector NuvleiLV( NucleiMomentum*decayingParticle.GetParticleMomentumDirection().x(),
                            NucleiMomentum*decayingParticle.GetParticleMomentumDirection().y(),
                            NucleiMomentum*decayingParticle.GetParticleMomentumDirection().z(),
                            NucleiEnergy);
    
   double positronMomentum = sqrt(total_energy_positron*total_energy_positron - electron_mass_c2*electron_mass_c2) ;  
    TLorentzVector positronLV( positronMomentum*positronDirection.x(),
                           positronMomentum*positronDirection.y(),
                           positronMomentum*positronDirection.z(),
                           total_energy_positron);
                           
   double electronMomentum = sqrt(total_energy_electron*total_energy_electron - electron_mass_c2*electron_mass_c2)  ;    
   TLorentzVector electronLV( electronMomentum*electronDirection.x(),
                           electronMomentum*electronDirection.y(),
                           electronMomentum*electronDirection.z(),
                           total_energy_electron);
                           
     // CM to lab boost positron emission                                  
    positronLV.Boost(NuvleiLV.BoostVector());
    positronDirection= G4ThreeVector(positronLV.Px(),
                                  positronLV.Py(),
                                  positronLV.Pz());

    electronLV.Boost(NuvleiLV.BoostVector());
    electronDirection= G4ThreeVector(electronLV.Px(),
                                  electronLV.Py(),
                                  electronLV.Pz());
                         
    // Add the pair to the stack
    Particle positronParticle(positronDefinition,theta_positron,positronLV.E(),positronDirection, decayingParticle.GetParticlePosition());
    m_ParticleStack->AddParticleToStack(positronParticle);
    Particle electronParticle(electronDefinition,theta_electron,electronLV.E(),electronDirection, decayingParticle.GetParticlePosition());
    m_ParticleStack->AddParticleToStack(electronParticle);
    
  }
  
}


//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
void EventGeneratorInternalPairFormation::SetTarget(Target* Target){
  m_Target = Target;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

void EventGeneratorInternalPairFormation::AddLeptonCascade(vector<double> Energies, double BranchingRatio,
														vector<string> FieldTypes, vector<double> PolarityOrders, 
														vector<double> InternalPairCoeff, vector<double> InternalElectronCoeff, 
														vector<string> InternalCSPairPath, vector<string> InternalCSPairName) { 											
	
	m_BranchingRatio.push_back(BranchingRatio);
	m_Energies.push_back(Energies);																
	m_FieldTypes.push_back(FieldTypes);
	m_PolarityOrders.push_back(PolarityOrders);
	m_InternalPairCoeff.push_back(InternalPairCoeff);
	m_InternalElectronCoeff.push_back(InternalElectronCoeff);
	cout<< "InternalCSPairPath " << InternalCSPairPath.size() <<  endl ; 
	m_CrossSectionLeptonPath.push_back(InternalCSPairPath); // For internal pair formation distribution 
		cout<< "InternalCSPairName " << InternalCSPairName.size() <<  endl ; 
	m_CrossSectionLeptonName.push_back(InternalCSPairName); // For internal pair formation distribution 
}
					

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
void EventGeneratorInternalPairFormation::PrepareCascade(){
		 
  // Change the given branching ratio so total is one (always have a decay during the event)
  double TotalRatio=0;
  for (unsigned int i = 0; i < m_BranchingRatio.size(); i++) {
    TotalRatio+=m_BranchingRatio[i]/100.;
  }
    
  // Check that the total ratio is not over 100% (below is allowed)
  if(TotalRatio>1) {
    G4cout << "Pair Decay Error: Sum of branching ratio is over 100%" << endl;
    exit(1);
  }
  
  for (unsigned int i = 0; i < m_BranchingRatio.size(); i++) {
    m_BranchingRatio[i]=(m_BranchingRatio[i]/TotalRatio)/100.;
  }
  
  // Shift the Branching ratio for faster shooting during event generation
  for (unsigned int i = 1; i < m_BranchingRatio.size(); i++) {
    m_BranchingRatio[i]=m_BranchingRatio[i-1]+m_BranchingRatio[i];
  }
  
  // Compute the total energy of the cascade
  double TotalEnergy=0;
  for (unsigned int i = 0 ; i < m_Energies.size(); i++) {
    TotalEnergy=0;
    for (unsigned int j = 0; j < m_Energies[i].size(); j++) {
      TotalEnergy+=m_Energies[i][j];
    }
    m_CascadeTotalEnergy.push_back(TotalEnergy);
  }
  
  // Transform the particle name to G4 standard: i.e: 10He -> He10
  m_NucleiName = m_ParticleStack->ChangeNameToG4Standard(m_NucleiName);
  if (m_NucleiName=="proton"   ||
      m_NucleiName=="deuteron" ||
      m_NucleiName=="triton"   ||
      m_NucleiName=="3He"      ||
      m_NucleiName=="alpha"    ){
    G4cout << "Pair Decay Error: Pair Decay not allowed for light particles" << endl;
    exit(1);
  }


  // Set the size of vector (holding the TH2F vectors) to the number of cascades
  m_CrossSectionLeptonHist2D.resize(m_BranchingRatio.size()); 
    
  /// Load the differential cross section
  for (unsigned int i = 0; i < m_BranchingRatio.size(); i++) {
	//Lepton distribution    
	for (unsigned int j = 0; j < m_Energies[i].size(); j++) {				 
		TH2F* h2 ;
		if(m_CrossSectionLeptonPath[i][j]!="born_approx") {
		h2 = Read2DProfile(m_CrossSectionLeptonPath[i][j],m_CrossSectionLeptonName[i][j]);
		}
		else{ // Use Born Approximation,
		double transition_energy = m_Energies[i][j];
		string FieldType = m_FieldTypes[i][j];
		double PolarityOrder = m_PolarityOrders[i][j]; 
		h2 = BuildCrossSection(transition_energy, FieldType, PolarityOrder, m_CrossSectionLeptonName[i][j]) ;
		}
		(m_CrossSectionLeptonHist2D[i]).push_back(h2);
	}
	
  }

//Inspect the histograms 

TFile f("/opt/NPTool/Outputs/Simulation/InspectPair.root","RECREATE") ;
	f.cd();
	for (unsigned int i = 0; i < m_CrossSectionLeptonHist2D.size(); i++) {
		
		G4cout << "Hello born_approx " << (m_CrossSectionLeptonHist2D[i]).size() << endl;	 std::cin.get() ; 	

		for (unsigned int j = 0 ; j < m_CrossSectionLeptonHist2D[i].size(); j++) {
		G4cout << "Hello born_approx " << m_CrossSectionLeptonHist2D[i][j]->GetEntries()<< endl;	 std::cin.get() ; 
					
		m_CrossSectionLeptonHist2D[i][j]->Write();
		}
	}
	f.Write();
	f.Close();
////////////////


}


//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
TH2F*  EventGeneratorInternalPairFormation::BuildCrossSection( double TransitionEnergy, string FieldType, double PolarityOrder, string HistName) {

//prepare the variables
double Ep, Em ; // kinetic energy of e+ and e-
double angle ; // angle of separation between e+ and e-
double cross_section ; // giving the number of pairs per unit energy, per |dCos(theta)|, per Quantum 

// prepare the fixed parameters
int    l = (int)PolarityOrder ; 
int Nbinx = 90 ; // energy
int Nbiny = 180; // angle

double Ep_max = TransitionEnergy - 2*electron_mass_c2  ; // maximum energy of the positron
double Ep_min = 0 ; // minimum energy of the positron
double angle_max = 180  ; // maximum separation angle
double angle_min = 0  ; // minimum separation angle

double M = electron_mass_c2 ; 
 
//prepare the histogram
TH2F* h2  = new TH2F (HistName.c_str(),HistName.c_str(),       Nbinx,Ep_min,Ep_max,      Nbiny,angle_min,angle_max) ; 

// intantiate the start values
angle = angle_min ; 
Ep = Ep_min ;
Em = Ep_max - Ep ;  

int counter = 0 ;  
while (Ep < Ep_max) // iterates on energy (x-axis)
{

	while (angle < angle_max) // iterates on angle (y-axis)
	{		
	 //Get Cross section in Born approximation and fill the histogram
	 int bin = h2->FindBin(Ep,angle);
	 cross_section = GetBornCrossSection(FieldType, TransitionEnergy, l, Ep*MeV, Em*MeV, angle*deg) ;	 
     	 //if(cross_section < 0.01 )
	 h2->SetBinContent(bin,cross_section);
	 
	 // increment angle 
	 angle = angle + ((angle_max - angle_min)/Nbiny);
	 
	 counter ++ ;
	  
	} 
	 // reset the angle
	 angle = angle_min ;
	 //increment kinetic energy values of e- and e+
	 Ep = Ep + ((Ep_max - Ep_min)/Nbinx) ; 
	 Em = Ep_max - Ep ;
}

cout << counter << endl ; cin.get() ; 	
	
return h2 ; 

}	
	
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
double EventGeneratorInternalPairFormation::GetBornCrossSection(string FieldType, double TransitionEnergy, int l, double Ep, double Em, double angle) { //Born approximation 
 
// for PolarityOrder > 0 : the cross section is a parametric function calculated by M.E.Rose [Phys. Rev. 76 (1949) 678 ] 
// this calculation is valid for Z < 41, Gamma Energy > 2.5 MeV
// for PolarityOrder = 0 : the cross section is as parametric function calculated by J.R.Oppenheimer [Phys. Rev. 60 (1941) 159 ]
// this calculation is valid for Z < ??, Gamma Energy > ?? MeV 
// In both cases more precise calculations could be made that are not addressed here and could be found in the litterature.

// N.B : in Rose paper,  hbar =  c  =  electron mass = 1, 
// all energy values should be devided by electron rest mass energy, 
// fine structure constant = elm_coupling/hbarc is multiplied by hbarc.
// This will not affect 

//Calculate primary parameters 
 double api = 2*(fine_structure_const*hbarc)/pi ; 
 double M = electron_mass_c2 /electron_mass_c2  ; // electron mass in units of electron_mass
 double k = TransitionEnergy /electron_mass_c2 ; // Energy of Transition in units of electron_mass
 	Ep = Ep /electron_mass_c2 ; // Energy of Transition in units of electron_mass
 	Em = Em /electron_mass_c2 ; // Energy of Transition in units of electron_mass
 
// calculate total (kinetic + rest mass) energy of e+ and e-
 double Wp = Ep + M ;   
 double Wm = Em + M ;
 double Pp = sqrt(Wp*Wp - M*M) ; //  momentum magnitudes of e+ 
 double Pm = sqrt(Wm*Wm - M*M) ; //                         e- 	
 double Q = Pp*Pp + Pm*Pm + 2*Pp*Pm*cos(angle) ; // sum of momenta 	
	 
 //Calculate secondary parameters
 double Q_k = Q/k ; 
 double kk_QQ = 1 ; //(k*k - Q*Q)  ;   MHD : Need to check the theory! 
 double pp_Q =  Pp*Pm/Q ;
 double pp_QQ =  Pp*Pm/(Q*Q) ;
 double Pp_Pmcos =  Pp + (Pm * cos(angle)) ;
 double Pm_Ppcos =  Pm + (Pp * cos(angle)) ; 
  
 // cross section parts
 double cs1 = 0  ; 
 double cs2 = 0  ;
     		
 if (FieldType == "M" || FieldType == "Magnetic" || FieldType == "MAGNETIC") {
 	if (l!=0) { // Ml (l>0)
	 cs1 = api * pp_Q * pow(Q_k,(2*l+1)) / (kk_QQ*kk_QQ) ;
	 //cs2 = 1 + (Wp*Wm) - ( pp_QQ * Pm_Ppcos * Pp_Pmcos ) ;
	 cs2 = M*M + (Wp*Wm) - ( pp_QQ * Pm_Ppcos * Pp_Pmcos ) ; 

	 //return ( pow(Q_k,(2*l+1)) / kk_QQ_2 ) ; 
	 return (cs1*cs2*sin(angle)) ; 
	}
	else cout << " Magnetic monopoles does not exist. Will exit " << endl ; 
 }
 else 
	if (FieldType == "E" || FieldType == "Electric" || FieldType == "ELECTRIC") {
		if (l>0) { // El (l>0) 
		 cs1 = api/(l+1) * pp_Q * pow(Q_k,(2*l-1)) / (kk_QQ*kk_QQ) ;
		 cs2 = (2*l+1) * (Wp*Wm + 1 - (1./3 * Pp * Pm * cos(angle) ) )  ;
		 cs2 = cs2 + l * ( Q_k*Q_k - 2 ) * ( Wp*Wm - 1 + ( Pp * Pm * cos(angle) ) ) ; 
		 cs2 = cs2 +  1./3 * (l-1) * (Pp*Pm)  * ( (3/(Q*Q)) * (Pm_Ppcos) * (Pp_Pmcos) - cos(angle) ) ;
		 return (cs1*cs2*sin(angle)) ; 
	 	} 
 		else { // E0 case 
 		 cs1 = Pp*Pm ;
 		 cs2 = (Wp*Wm - M*M + Pp*Pm*cos(angle)) ;  
 		 return (cs1*cs2*sin(angle)) ; 
 		}
    }
  	else { 
	G4cout << "Field type can only be E / Electric / ELECTRIC (for Electric) or M / Magnetic / MAGNETIC (for Magnetic) " << endl;
    exit(1);
    return 0 ; 			
	}
	
}
 
  

